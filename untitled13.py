# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xsRIGd8mzRFYrTEL9WcH5yqnZ4qXcHhS
"""

import streamlit as st
import numpy as np
from scipy.stats import norm
from scipy.optimize import brentq

# === Fun√ß√µes de precifica√ß√£o ===

# Black-Scholes para op√ß√µes europeias
def black_scholes(S, K, T, r, sigma, option_type='call'):
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    if option_type == 'call':
        return S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
    else:
        return K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)

# Volatilidade impl√≠cita via m√©todo de Brent
def implied_volatility(option_price, S, K, T, r, option_type='call'):
    def objective(sigma):
        return black_scholes(S, K, T, r, sigma, option_type) - option_price
    try:
        return brentq(objective, 1e-6, 5)
    except ValueError:
        return np.nan

# Aproxima√ß√£o para op√ß√µes americanas (mesmo pre√ßo do modelo europeu)
def american_option_approx(S, K, T, r, sigma, option_type='call'):
    return black_scholes(S, K, T, r, sigma, option_type)

# Op√ß√µes asi√°ticas com m√©dia geom√©trica (solu√ß√£o anal√≠tica)
def asian_geometric_option(S, K, T, r, sigma, option_type='call'):
    sigma_adj = sigma * np.sqrt((2 * T + 1) / (6 * (T + 1)))
    r_adj = 0.5 * (r - 0.5 * sigma**2) + 0.5 * sigma_adj**2
    d1 = (np.log(S / K) + (r_adj + 0.5 * sigma_adj**2) * T) / (sigma_adj * np.sqrt(T))
    d2 = d1 - sigma_adj * np.sqrt(T)
    if option_type == 'call':
        return np.exp(-r * T) * (S * np.exp(r_adj * T) * norm.cdf(d1) - K * norm.cdf(d2))
    else:
        return np.exp(-r * T) * (K * norm.cdf(-d2) - S * np.exp(r_adj * T) * norm.cdf(-d1))

# === Interface Streamlit ===

st.title("üìà Calculadora de Op√ß√µes e Volatilidade Impl√≠cita")

S = st.number_input("üí∞ Pre√ßo do ativo (S)", value=100.0)
K = st.number_input("üéØ Pre√ßo de exerc√≠cio (K)", value=100.0)
T = st.number_input("‚è≥ Tempo at√© o vencimento (T, em anos)", value=1.0)
r = st.number_input("üè¶ Taxa de juros livre de risco (r)", value=0.05)
sigma = st.number_input("üìä Volatilidade (œÉ)", value=0.2)
option_type = st.selectbox("üìò Tipo da op√ß√£o", ['call', 'put'])
model = st.selectbox("‚öôÔ∏è Modelo de op√ß√£o", ['Europeia', 'Americana', 'Asi√°tica'])
calcular_vol = st.checkbox("üîç Calcular volatilidade impl√≠cita a partir do pre√ßo de mercado")

if calcular_vol:
    market_price = st.number_input("üíπ Pre√ßo de mercado da op√ß√£o", value=10.0)
    vol = implied_volatility(market_price, S, K, T, r, option_type)
    if not np.isnan(vol):
        st.success(f"Volatilidade impl√≠cita estimada: **{vol:.4f}**")
    else:
        st.error("N√£o foi poss√≠vel calcular a volatilidade impl√≠cita.")
else:
    if model == 'Europeia':
        price = black_scholes(S, K, T, r, sigma, option_type)
    elif model == 'Americana':
        price = american_option_approx(S, K, T, r, sigma, option_type)
    elif model == 'Asi√°tica':
        price = asian_geometric_option(S, K, T, r, sigma, option_type)

    st.success(f"Pre√ßo da op√ß√£o {model.lower()}: **{price:.4f}**")